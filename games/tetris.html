<!-- source https://gemini.google.com/app/d09ad7c10448fd6b -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Tetris</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="../math/mathTests.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0d0d0d;
            --main-color: #d4d4d4;
            --accent-color: #fca5a5;
            --border-color: #404040;
            --game-bg: #1a1a1a;
        }

        body {
            font-family: 'Press Start 2P', cursive;
            background-color: var(--bg-color);
            color: var(--main-color);
            overscroll-behavior: none;
        }

        /* Safe-area padding helper for devices with bottom bars (iOS/Android) */
        .mb-safe {
            padding-bottom: constant(safe-area-inset-bottom);
            padding-bottom: env(safe-area-inset-bottom);
        }

        /* Custom styling for the retro look */
        .pixel-border {
            border: 4px solid var(--border-color);
            box-shadow: 
                inset -4px -4px 0px 0px #000000,
                inset 4px 4px 0px 0px #5a5a5a;
            background-color: var(--game-bg);
        }

        .pixel-button {
            border: 3px solid var(--border-color);
            background-color: var(--main-color);
            color: var(--bg-color);
            box-shadow: 
                inset -3px -3px 0px 0px #7a7a7a,
                inset 3px 3px 0px 0px #ffffff;
            transition: all 0.1s ease-in-out;
            user-select: none;
        }
        .pixel-button:active {
            box-shadow: inset 2px 2px 0px 0px #7a7a7a;
            transform: translateY(2px);
        }

        .text-shadow {
            text-shadow: 2px 2px #000000;
        }

        /* Prevent ugly blue highlight on mobile buttons */
        .mobile-control-btn {
            -webkit-tap-highlight-color: transparent;
        }
        
        canvas {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .mathProblem {
            font-size: 24px;
            color: var(--accent-color);
            text-shadow: 2px 2px 0 #000;
        }

        .mathInput {
            width: 80px;
            height: 50px;
            font-size: 24px;
            text-align: center;
            border: 3px solid var(--accent-color);
            border-radius: 5px;
            background: #fff;
            color: #000;
            margin: 10px;
            font-family: 'Press Start 2P', cursive;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: textfield;
            touch-action: manipulation;
        }
        
        .mathInput::-webkit-outer-spin-button,
        .mathInput::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .mathSubmit {
            margin-top: 20px;
            padding: 12px 24px;
            background: #FF9800;
            border: none;
            color: white;
            font-size: 16px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            box-shadow: 0 3px 0 #F57C00;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            min-height: 44px; /* iOS recommended minimum touch target */
        }

        .mathSubmit:active {
            transform: translateY(2px);
            box-shadow: 0 1px 0 #F57C00;
        }

        .mathResult {
            font-size: 14px;
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
        }

        .mathResult.correct {
            background: rgba(76, 175, 80, 0.3);
            color: #4CAF50;
        }

        .mathResult.incorrect {
            background: rgba(244, 67, 54, 0.3);
            color: #F44336;
        }

        .progressBar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progressFill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-color), #ff6b9d);
            transition: width 0.3s ease;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal.visible {
            opacity: 1;
            pointer-events: all;
        }

        .modal .pixel-border {
            transform: scale(0.8);
            transition: transform 0.3s ease;
        }

        .modal.visible .pixel-border {
             transform: scale(1);
        }

        .grade-btn {
            font-size: 0.7rem;
            padding: 0.5rem;
            min-height: 3rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .grade-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #F57C00;
        }

        .grade-btn:active {
            transform: translateY(0px);
            box-shadow: 0 2px 0 #F57C00;
        }

        /* Hide mobile instructions during gameplay */
        .mobile-instructions-hidden {
            display: none !important;
        }

    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-1 sm:p-2 touch-none">

    <!-- Stats Section (Above Grid) -->
    <div class="w-full max-w-md mx-auto mb-2">
        <div class="grid grid-cols-4 gap-2 sm:gap-4 text-center">
            <div class="pixel-border p-1 sm:p-2">
                <span class="text-accent-color text-xs">SCORE</span>
                <p id="score" class="text-xs sm:text-sm leading-tight">0</p>
            </div>
            <div class="pixel-border p-1 sm:p-2">
                <span class="text-accent-color text-xs">LINES</span>
                <p id="lines" class="text-xs sm:text-sm leading-tight">0</p>
            </div>
            <div class="pixel-border p-1 sm:p-2">
                <span class="text-accent-color text-xs">LEVEL</span>
                <p id="level" class="text-xs sm:text-sm leading-tight">1</p>
            </div>
            <div class="pixel-border p-1 sm:p-2">
                <span class="text-accent-color text-xs">NEXT</span>
                <canvas id="next" class="mx-auto w-8 h-8 sm:w-12 sm:h-12"></canvas>
            </div>
        </div>
    </div>

    <!-- Game Board Section -->
    <div class="w-full max-w-md mx-auto mb-2 flex justify-center">
        <canvas id="tetris" class="pixel-border"></canvas>
    </div>

    <!-- Controls Section (Below Grid) -->
    <div class="w-full max-w-md mx-auto px-1 mb-safe">
        <div class="mb-2">
            <h3 class="text-center mb-1 text-sm">Difficulty</h3>
            <div class="flex justify-between">
                <button id="easy-btn" class="pixel-button flex-1 mx-1 px-2 py-1 text-xs">Easy</button>
                <button id="medium-btn" class="pixel-button flex-1 mx-1 px-2 py-1 text-xs !bg-accent-color !text-white">Medium</button>
                <button id="hard-btn" class="pixel-button flex-1 mx-1 px-2 py-1 text-xs">Hard</button>
            </div>
        </div>
        <button id="start-btn" class="pixel-button w-full py-2 text-sm px-3 overflow-visible whitespace-nowrap">Start Game</button>
    </div>

    <!-- Grade Selection Modal -->
    <div id="grade-modal" class="modal">
        <div class="pixel-border p-8 text-center max-w-sm w-full">
            <h2 class="text-2xl text-accent-color text-shadow mb-4">üìö Choose Your Grade üìö</h2>
            <p class="mb-6 text-sm">Select your math grade level for the challenges!</p>
            <div class="grid grid-cols-3 gap-2 mb-4">
                <button class="grade-btn pixel-button py-2" data-grade="1">Grade 1</button>
                <button class="grade-btn pixel-button py-2" data-grade="2">Grade 2</button>
                <button class="grade-btn pixel-button py-2" data-grade="3">Grade 3</button>
                <button class="grade-btn pixel-button py-2" data-grade="4">Grade 4</button>
                <button class="grade-btn pixel-button py-2" data-grade="5">Grade 5</button>
            </div>
        </div>
    </div>

    <!-- Mobile Touch Instructions -->
    <div id="mobile-instructions" class="lg:hidden mt-2 p-2 text-center">
        <div class="text-xs text-accent-color bg-black bg-opacity-50 rounded p-2 pixel-border">
            <p class="mb-1">üì± Touch Controls:</p>
            <p>‚Ä¢ Tap the falling piece to rotate</p>
            <p>‚Ä¢ Drag left/right to move</p>
            <p>‚Ä¢ Drag down to hard drop</p>
        </div>
    </div>

    <!-- Desktop Controls Footnote -->
    <div class="hidden lg:block fixed bottom-4 left-1/2 transform -translate-x-1/2 text-xs text-center text-main-color opacity-75">
        <p><span class="text-accent-color">Desktop Controls:</span> Arrow Keys to move/rotate, Space for hard drop</p>
    </div>


    <!-- Modal Dialog -->
    <div id="modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
        <div class="pixel-border p-8 text-center max-w-sm w-full">
            <h2 id="modal-title" class="text-3xl text-accent-color text-shadow mb-4">Game Over</h2>
            <p id="modal-score" class="mb-6 text-xl">Final Score: 0</p>
            <button id="modal-button" class="pixel-button w-full py-3 text-lg">Play Again</button>
        </div>
    </div>

    <!-- Math Modal Dialog -->
    <div id="math-modal" class="modal">
        <div class="pixel-border p-8 text-center max-w-sm w-full">
            <h2 class="text-2xl text-accent-color text-shadow mb-4">üßÆ Math Challenge! üßÆ</h2>
            <div class="progressBar mb-4">
                <div class="progressFill" id="mathProgress" style="width: 0%"></div>
            </div>
            <p class="mb-4 text-sm">Solve the math problem to continue!</p>
            <div class="mathProblem mb-4" id="mathProblem"></div>
            <input type="text" class="mathInput mb-4" id="mathAnswer" placeholder="?" inputmode="numeric" pattern="[0-9]*">
            <button class="mathSubmit mb-4" id="mathSubmitBtn">Submit Answer</button>
            <div id="mathResult"></div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Game Setup ---
            const canvas = document.getElementById('tetris');
            const context = canvas.getContext('2d');
            const nextCanvas = document.getElementById('next');
            const nextContext = nextCanvas.getContext('2d');

            const scoreElement = document.getElementById('score');
            const linesElement = document.getElementById('lines');
            const levelElement = document.getElementById('level');
            const startBtn = document.getElementById('start-btn');
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalScore = document.getElementById('modal-score');
            const modalButton = document.getElementById('modal-button');
            const easyBtn = document.getElementById('easy-btn');
            const mediumBtn = document.getElementById('medium-btn');
            const hardBtn = document.getElementById('hard-btn');

            // Modal elements
            const gradeModal = document.getElementById('grade-modal');
            const gradeBtns = document.querySelectorAll('.grade-btn');

            // Math modal elements
            const mathModal = document.getElementById('math-modal');
            const mathProblem = document.getElementById('mathProblem');
            const mathAnswer = document.getElementById('mathAnswer');
            const mathResult = document.getElementById('mathResult');
            const mathProgress = document.getElementById('mathProgress');
            const mathSubmitBtn = document.getElementById('mathSubmitBtn');
            const mobileInstructions = document.getElementById('mobile-instructions');

            // Math tests module instance
            const mathTests = new MathTests();

            // Selected grade level
            let selectedGrade = 3; // Default to grade 3

            // Touch control variables
            let touchStartX = 0;
            let touchStartY = 0;
            let touchStartTime = 0;
            let isDragging = false;
            let dragThreshold = 50; // Increased minimum distance for drag detection
            let tapThreshold = 200; // Maximum time for tap detection (ms)
            let lastMoveTime = 0; // For debouncing movement
            let moveDebounceDelay = 150; // Minimum time between moves (ms)
            let lastDropTime = 0; // For debouncing drops
            let dropDebounceDelay = 300; // Minimum time between drops (ms)
            let isHardDropping = false; // Prevent multiple hard drops

            const COLS = 10;
            const ROWS = 20;
            const BLOCK_SIZE = 30; // Initial block size
            const NEXT_GRID_SIZE = 4;
            
            let board = createBoard();
            let piece = null;
            let nextPiece = null;
            
            let score = 0;
            let lines = 0;
            let level = 1;
            
            let dropCounter = 0;
            let dropInterval = 1000; // ms
            let lastTime = 0;
            let isPaused = true;
            let isGameOver = false;

            const difficulties = {
                easy: 1000,
                medium: 600,
                hard: 200,
            };
            let currentDifficulty = 'medium';

            const COLORS = [
                null,
                '#FF0D72', // T
                '#0DC2FF', // I
                '#0DFF72', // O
                '#F538FF', // L
                '#FF8E0D', // J
                '#FFE138', // S
                '#3877FF', // Z
            ];
            
            // --- Audio Setup (Tone.js) ---
            let musicStarted = false;
            let synth, lineClearSynth, gameOverSynth;
            
            const musicLoop = new Tone.Sequence((time, note) => {
                synth.triggerAttackRelease(note, "8n", time);
            }, ["C4", ["E4", "G4"], "C5", ["E4", "G4"], "C4", ["D4", "F4"], "B3", ["D4", "F4"]], "4n");
            
            function setupAudio() {
                synth = new Tone.Synth({
                    oscillator: { type: "square" },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 0.5 }
                }).toDestination();
                
                 lineClearSynth = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0.2, release: 0.2 }
                }).toDestination();

                gameOverSynth = new Tone.Synth({
                    oscillator: { type: "sawtooth" },
                    envelope: { attack: 0.01, decay: 0.5, sustain: 0.1, release: 1 }
                }).toDestination();
            }
            
            function playSound(type) {
                if (!musicStarted) return;
                const now = Tone.now();
                switch(type) {
                    case 'move':
                        synth.triggerAttackRelease("C3", "16n", now);
                        break;
                    case 'rotate':
                        synth.triggerAttackRelease("E3", "16n", now);
                        break;
                    case 'hard_drop':
                        synth.triggerAttackRelease("G2", "16n", now);
                        break;
                    case 'line_clear':
                        lineClearSynth.triggerAttackRelease("C5", "8n", now);
                        lineClearSynth.triggerAttackRelease("E5", "8n", now + 0.1);
                        lineClearSynth.triggerAttackRelease("G5", "8n", now + 0.2);
                        break;
                    case 'game_over':
                        gameOverSynth.triggerAttackRelease("C3", "2n", now);
                        gameOverSynth.triggerAttackRelease("B2", "2n", now + 0.2);
                        gameOverSynth.triggerAttackRelease("A#2", "2n", now + 0.4);
                        break;
                }
            }

            // --- Game Logic ---
            function createBoard() {
                return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            }

            function createPiece(type) {
                switch (type) {
                    case 'T': return [[1, 1, 1], [0, 1, 0]];
                    case 'I': return [[2, 2, 2, 2]];
                    case 'O': return [[3, 3], [3, 3]];
                    case 'L': return [[0, 0, 4], [4, 4, 4]];
                    case 'J': return [[5, 0, 0], [5, 5, 5]];
                    case 'S': return [[0, 6, 6], [6, 6, 0]];
                    case 'Z': return [[7, 7, 0], [0, 7, 7]];
                }
            }

            function resetPiece() {
                const pieces = 'TIOJLSZ';
                const type = pieces[Math.floor(Math.random() * pieces.length)];
                if (!nextPiece) {
                    const nextType = pieces[Math.floor(Math.random() * pieces.length)];
                    nextPiece = {
                        matrix: createPiece(nextType),
                        pos: { x: 0, y: 0 },
                        type: nextType
                    };
                }
                
                piece = {
                    matrix: nextPiece.matrix,
                    pos: {
                        x: Math.floor(COLS / 2) - Math.floor(nextPiece.matrix[0].length / 2),
                        y: 0
                    },
                    type: nextPiece.type
                };
                
                const nextType = pieces[Math.floor(Math.random() * pieces.length)];
                nextPiece = {
                     matrix: createPiece(nextType),
                     pos: {x: 0, y: 0},
                     type: nextType
                };
                
                if (checkCollision(board, piece)) {
                    gameOver();
                }
                drawNextPiece();
            }

            function pieceDrop() {
                piece.pos.y++;
                if (checkCollision(board, piece)) {
                    piece.pos.y--;
                    merge(board, piece);
                    sweepBoard();
                    resetPiece();
                    updateScore(0);
                }
                dropCounter = 0;
            }
            
            function hardDrop() {
                if (isPaused || isHardDropping) return;
                
                isHardDropping = true; // Set flag to prevent multiple drops
                
                while (!checkCollision(board, piece)) {
                    piece.pos.y++;
                }
                piece.pos.y--;
                merge(board, piece);
                sweepBoard();
                resetPiece();
                updateScore(2); // 2 points per hard drop
                playSound('hard_drop');
                
                // Reset flag after a short delay to allow next drop
                setTimeout(() => {
                    isHardDropping = false;
                }, 500);
            }


            function pieceMove(dir) {
                piece.pos.x += dir;
                if (checkCollision(board, piece)) {
                    piece.pos.x -= dir;
                } else {
                    playSound('move');
                }
            }

            function rotate(matrix) {
                const newMatrix = matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]).reverse());
                return newMatrix;
            }
            
            function pieceRotate() {
                const originalPos = piece.pos.x;
                let offset = 1;
                const rotated = rotate(piece.matrix);
                
                piece.matrix = rotated;
                
                while(checkCollision(board, piece)) {
                    piece.pos.x += offset;
                    offset = -(offset + (offset > 0 ? 1 : -1));
                    if (offset > piece.matrix[0].length) {
                        piece.matrix = rotate(rotate(rotate(piece.matrix))); // rotate back
                        piece.pos.x = originalPos;
                        return;
                    }
                }
                playSound('rotate');
            }

            function checkCollision(board, piece) {
                for (let y = 0; y < piece.matrix.length; ++y) {
                    for (let x = 0; x < piece.matrix[y].length; ++x) {
                        if (piece.matrix[y][x] !== 0 &&
                           (board[y + piece.pos.y] &&
                            board[y + piece.pos.y][x + piece.pos.x]) !== 0) {
                            return true;
                        }
                    }
                }
                return false;
            }

            function merge(board, piece) {
                piece.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            board[y + piece.pos.y][x + piece.pos.x] = value;
                        }
                    });
                });
            }
            
            function sweepBoard() {
                let clearedLines = 0;
                outer: for (let y = board.length - 1; y > 0; --y) {
                    for (let x = 0; x < board[y].length; ++x) {
                        if (board[y][x] === 0) {
                            continue outer;
                        }
                    }

                    const row = board.splice(y, 1)[0].fill(0);
                    board.unshift(row);
                    ++y;
                    
                    clearedLines++;
                }
                
                if (clearedLines > 0) {
                    lines += clearedLines;
                    updateScore(clearedLines * 10 * clearedLines); // Bonus for multiple lines
                    playSound('line_clear');
                    
                    // Update level
                    level = Math.floor(lines / 10) + 1;
                    dropInterval = difficulties[currentDifficulty] - (level - 1) * 50;
                    if (dropInterval < 50) dropInterval = 50;
                }
            }

            function updateScore(amount) {
                score += amount;
                scoreElement.innerText = score;
                linesElement.innerText = lines;
                levelElement.innerText = level;
            }

            // --- Drawing ---
            function draw() {
                // Draw main board
                context.fillStyle = '#1a1a1a';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw grid lines
                const currentBlockSize = canvas.width / COLS;
                context.strokeStyle = 'rgba(128, 128, 128, 0.1)';
                context.lineWidth = 1;
                for (let x = 0; x < COLS; x++) {
                    for (let y = 0; y < ROWS; y++) {
                        context.strokeRect(x * currentBlockSize, y * currentBlockSize, currentBlockSize, currentBlockSize);
                    }
                }

                drawMatrix(context, board, { x: 0, y: 0 });
                if (piece) {
                    drawMatrix(context, piece.matrix, piece.pos);
                }
            }

            function drawMatrix(context, matrix, offset) {
                matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            context.fillStyle = COLORS[value];
                            const currentBlockSize = canvas.width / COLS;
                            context.fillRect(
                                (x + offset.x) * currentBlockSize,
                                (y + offset.y) * currentBlockSize,
                                currentBlockSize, currentBlockSize);
                            
                            // Add a little 3D effect
                            context.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                            context.lineWidth = 2;
                            context.strokeRect(
                                (x + offset.x) * currentBlockSize + 1,
                                (y + offset.y) * currentBlockSize + 1,
                                currentBlockSize - 2, currentBlockSize - 2);
                        }
                    });
                });
            }
            
            function drawNextPiece() {
                const blockSize = nextCanvas.width / NEXT_GRID_SIZE;
                nextContext.fillStyle = '#1a1a1a';
                nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
                
                const matrix = nextPiece.matrix;
                const offsetX = (NEXT_GRID_SIZE - matrix[0].length) / 2;
                const offsetY = (NEXT_GRID_SIZE - matrix.length) / 2;

                matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            nextContext.fillStyle = COLORS[value];
                            nextContext.fillRect(
                                (x + offsetX) * blockSize,
                                (y + offsetY) * blockSize,
                                blockSize, blockSize
                            );
                             // Add a little 3D effect
                            nextContext.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                            nextContext.lineWidth = 2;
                            nextContext.strokeRect(
                                (x + offsetX) * blockSize + 1,
                                (y + offsetY) * blockSize + 1,
                                blockSize - 2, blockSize - 2);
                        }
                    });
                });
            }


            // --- Game Loop ---
            function update(time = 0) {
                if (isPaused || isGameOver) {
                    return;
                }

                const deltaTime = time - lastTime;
                lastTime = time;

                dropCounter += deltaTime;
                if (dropCounter > dropInterval) {
                    pieceDrop();
                }
                
                draw();
                requestAnimationFrame(update);
            }

            // --- Game State Control ---
            function startGame() {
                isPaused = false;
                isGameOver = false;
                board = createBoard();
                score = 0;
                lines = 0;
                level = 1;
                dropInterval = difficulties[currentDifficulty];
                updateScore(0);
                resetPiece();
                modal.classList.remove('visible');
                startBtn.textContent = "Pause Game";
                
                // Hide mobile instructions during gameplay
                if (mobileInstructions) {
                    mobileInstructions.classList.add('mobile-instructions-hidden');
                }

                if (!musicStarted) {
                    Tone.start();
                    setupAudio();
                    musicLoop.start(0);
                    Tone.Transport.start();
                    musicStarted = true;
                }
                if (Tone.Transport.state !== 'started') {
                    Tone.Transport.start();
                }
                
                update();
            }

            function pauseGame() {
                isPaused = !isPaused;
                if (isPaused) {
                    startBtn.textContent = "Resume Game";
                    if(musicStarted) Tone.Transport.pause();
                    
                    // Show mobile instructions when paused
                    if (mobileInstructions) {
                        mobileInstructions.classList.remove('mobile-instructions-hidden');
                    }
                } else {
                    startBtn.textContent = "Pause Game";
                    if(musicStarted) Tone.Transport.start();
                    
                    // Hide mobile instructions when resuming
                    if (mobileInstructions) {
                        mobileInstructions.classList.add('mobile-instructions-hidden');
                    }
                    update();
                }
            }

            function gameOver() {
                isGameOver = true;
                isPaused = true;
                playSound('game_over');
                if(musicStarted) Tone.Transport.stop();

                // Show mobile instructions when game is over
                if (mobileInstructions) {
                    mobileInstructions.classList.remove('mobile-instructions-hidden');
                }

                // Show game over modal directly
                modalTitle.textContent = "Game Over";
                modalScore.innerText = `Final Score: ${score}`;
                modalButton.textContent = "Play Again";
                modal.classList.add('visible');
            }

            function startMathExercise() {
                const problem = mathTests.startMathExercise(selectedGrade, 3); // Use selected grade, 3 exercises
                mathProblem.textContent = problem.problem;

                mathAnswer.value = '';
                mathResult.innerHTML = '';
                mathProgress.style.width = '0%';

                mathModal.classList.add('visible');
            }

            function submitMathAnswer() {
                // Clean the input value - remove any non-numeric characters
                const cleanValue = mathAnswer.value.replace(/[^0-9]/g, '');
                const userAnswer = parseInt(cleanValue);
                
                if (isNaN(userAnswer) || cleanValue === '') {
                    mathResult.innerHTML = '<div class="mathResult incorrect">‚ùå Please enter a valid number</div>';
                    return;
                }

                const result = mathTests.submitMathAnswer(userAnswer);

                if (result.isCorrect) {
                    mathResult.innerHTML = '<div class="mathResult correct">‚úÖ Correct! Well done!</div>';
                } else {
                    mathResult.innerHTML = `<div class="mathResult incorrect">‚ùå Wrong! The answer was ${result.correctAnswer}</div>`;
                }

                mathProgress.style.width = `${(result.exerciseCount / 3) * 100}%`;

                if (!result.isSessionComplete) {
                    setTimeout(() => {
                        mathProblem.textContent = result.nextProblem.problem;
                        mathAnswer.value = '';
                        mathResult.innerHTML = '';
                    }, 1500);
                } else {
                    setTimeout(() => {
                        finishMathSession();
                    }, 1500);
                }
            }

            function finishMathSession() {
                mathModal.classList.remove('visible');

                // Start the actual game after math is completed
                startGame();
            }
            
            // --- UI & Event Listeners ---
            function handleStartClick() {
                if (isGameOver) {
                    startGame();
                } else if (isPaused) {
                    if (startBtn.textContent === "Start Game") {
                        // Show grade selection first
                        showGradeSelection();
                    } else {
                        pauseGame();
                    }
                } else {
                    pauseGame();
                }
            }

            function showGradeSelection() {
                gradeModal.classList.add('visible');
            }

            function selectGrade(grade) {
                selectedGrade = grade;
                gradeModal.classList.remove('visible');
                startMathExercise();
            }
            
            startBtn.addEventListener('click', handleStartClick);
            modalButton.addEventListener('click', startGame);
            
            // Math submit button event listeners (both click and touch for iPad compatibility)
            mathSubmitBtn.addEventListener('click', submitMathAnswer);
            mathSubmitBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                submitMathAnswer();
            });
            
            // Input validation for math answer field
            mathAnswer.addEventListener('input', (e) => {
                // Only allow numeric input
                e.target.value = e.target.value.replace(/[^0-9]/g, '');
            });
            
            mathAnswer.addEventListener('keypress', (e) => {
                // Only allow numeric keys
                if (!/[0-9]/.test(e.key) && e.key !== 'Enter') {
                    e.preventDefault();
                }
            });

            document.addEventListener('keydown', event => {
                // Handle Enter key for math input
                if (event.key === 'Enter' && mathModal.classList.contains('visible')) {
                    submitMathAnswer();
                    return;
                }

                if(isPaused) return;
                switch (event.code) {
                    case 'ArrowLeft':
                    case 'KeyA':
                        pieceMove(-1);
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        pieceMove(1);
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        pieceDrop();
                        break;
                    case 'ArrowUp':
                    case 'KeyW':
                        pieceRotate();
                        break;
                    case 'Space':
                        event.preventDefault(); // prevent page scroll
                        hardDrop();
                        break;
                }
            });

            // Touch Controls for Mobile
            function getTouchPos(canvas, touchEvent) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: touchEvent.touches[0].clientX - rect.left,
                    y: touchEvent.touches[0].clientY - rect.top
                };
            }

            canvas.addEventListener('touchstart', (e) => {
                if (isPaused) return;
                e.preventDefault();

                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                touchStartTime = Date.now();
                isDragging = false;
            });

            canvas.addEventListener('touchmove', (e) => {
                if (isPaused) return;
                e.preventDefault();

                const touch = e.touches[0];
                const deltaX = touch.clientX - touchStartX;
                const deltaY = touch.clientY - touchStartY;
                const currentTime = Date.now();

                // If moved more than threshold, consider it a drag
                if (Math.abs(deltaX) > dragThreshold || Math.abs(deltaY) > dragThreshold) {
                    isDragging = true;

                    // Horizontal drag for left/right movement
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        // Debounce horizontal movement
                        if (currentTime - lastMoveTime > moveDebounceDelay) {
                            if (deltaX > dragThreshold && touchStartX < touch.clientX) {
                                pieceMove(1); // Move right
                                touchStartX = touch.clientX; // Reset for continuous movement
                                lastMoveTime = currentTime;
                            } else if (deltaX < -dragThreshold && touchStartX > touch.clientX) {
                                pieceMove(-1); // Move left
                                touchStartX = touch.clientX; // Reset for continuous movement
                                lastMoveTime = currentTime;
                            }
                        }
                    }
                    // Vertical downward drag for hard drop - requires more deliberate movement
                    else if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY > dragThreshold * 2) {
                        // Debounce drops more aggressively and check if already dropping
                        if (currentTime - lastDropTime > dropDebounceDelay && !isHardDropping) {
                            hardDrop(); // Hard drop on downward drag
                            touchStartY = touch.clientY; // Reset to prevent repeated drops
                            lastDropTime = currentTime;
                        }
                    }
                }
            });

            canvas.addEventListener('touchend', (e) => {
                if (isPaused) return;
                e.preventDefault();

                const touchEndTime = Date.now();
                const touchDuration = touchEndTime - touchStartTime;

                // If it's a quick tap (not a drag), rotate the piece
                if (!isDragging && touchDuration < tapThreshold) {
                    pieceRotate();
                }

                // Reset drag state
                isDragging = false;
            });
            
            // Difficulty Selection
            function setDifficulty(level) {
                currentDifficulty = level;
                dropInterval = difficulties[level];
                
                [easyBtn, mediumBtn, hardBtn].forEach(btn => {
                    btn.classList.remove('!bg-accent-color', '!text-white');
                });
                document.getElementById(`${level}-btn`).classList.add('!bg-accent-color', '!text-white');
            }
            
            easyBtn.addEventListener('click', () => setDifficulty('easy'));
            mediumBtn.addEventListener('click', () => setDifficulty('medium'));
            hardBtn.addEventListener('click', () => setDifficulty('hard'));

            // Grade selection event listeners
            gradeBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const grade = parseInt(e.currentTarget.dataset.grade);
                    selectGrade(grade);
                });
            });
            
            // --- Responsive Canvas ---
            function resizeCanvas() {
                const container = canvas.parentElement;

                // Account for stats above and controls below the grid
                // Approximate space used by other elements: stats (~60px), controls (~80px), padding (~40px)
                // Reserve extra space on mobile to avoid bottom UI and safe areas cutting off controls
                const reservedSpace = window.innerWidth < 640 ? 220 : 220;
                const availableHeight = window.innerHeight - reservedSpace;

                // Calculate size based on available width and height
                const maxWidth = container.clientWidth;
                const maxHeight = availableHeight;
                const sizeByWidth = Math.floor(maxWidth / COLS);
                const sizeByHeight = Math.floor(maxHeight / ROWS);

                // Use the smaller of the two to ensure it fits
                const newBlockSize = Math.min(sizeByWidth, sizeByHeight, 30); // Cap at 30px for visibility

                canvas.width = newBlockSize * COLS;
                canvas.height = newBlockSize * ROWS;

                nextCanvas.width = newBlockSize * NEXT_GRID_SIZE;
                nextCanvas.height = newBlockSize * NEXT_GRID_SIZE;

                draw();
                if(nextPiece) drawNextPiece();
            }

            window.addEventListener('resize', resizeCanvas);
            
            // Initial setup
            resizeCanvas();
            setDifficulty('medium');
            
        });
    </script>
</body>
</html>



